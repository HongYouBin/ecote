# ecote

### 11번 뱀 327p
https://www.acmicpc.net/problem/3190

https://github.com/HongYouBin/ecote/blob/main/11.cpp
- 차근차근 설명에 나온 방법으로 구현하면 쉬운 문제였다. 침착하게 대응하지 못했다.
- 14행 
  - 함수를 만들 때 삼항연산자를 사용하면 간단하게 작성할 수 있다. 조건문이 다양하게 나올 때 삼항연산자를 사용하도록 할 것
- 20행, 21행 
  - 방향 전환할 때 dx는 row(행), dy는 colum(열)로 작성해야 한다. 반대로 해서 결과가 잘못 나왔다. 남쪽으로 갈수록 증가한다. 행의 값이 아래로 갈수록 증가 반대로 생각해서 결과가 잘못 나왔다.
- 41행
  - 뱀이 머물고 있는 방향을 설정할 때 배열을 하나 더 만들어서 메모리를 잡아먹었는데 그럴 필요 없이 기존 배열 arr를 재활용 하면 된다. 0이면 방문하지 않은 곳, 1이면 사과가 있는곳, 2이면 방문한 곳으로 설정
- 42행 
  - 뱀이 사과를 먹지 않아 크기가 늘어나지 않을 때 뱀이 가장 마지막에 방문한 곳을 지워줘야 한다. 아이디어가 떠오르지 않았다. 답을 보니 queue를 사용하여 마지막으로 방문한 곳을 지웠다. 해결 방법을 좀더 고민해봤어야 할 것 같다
  - 55행에서 queue를 이용하여 마지막 방문한 곳을 지우는 과정 확인 가능하다.
- 44행
  - 왼쪽 위부터 시작해 1, 1부터 시작했어야 했지만 실수로 오른쪽 위부터 시작하도록 좌표를 설정하는 실수를 했다.
- 14행
  - 함수 turn에서 왼쪽으로 방향을 바꿀 때 direction - 1 연산을 해줘야 되지만 더했다. 정신차리고 실수하지 않도록 확인해야 한다.
  
### 12번 기둥과 보 설치 329p
https://programmers.co.kr/learn/courses/30/lessons/60061

https://github.com/HongYouBin/ecote/blob/main/12.cpp
- 아이디어를 떠오르는 것은 어렵지 않았으나 코드 구현과정이 복잡하여 실수할 가능성이 높고, 중간중간 위기가 찾아왔다. 
- 시간을 5초 줬기 때문에 제시된 조건을 처음부터 끝까지 하나하나 다 확인 가능하다. 새로 추가되거나 삭제될 때 조건을 만족하는지 현재 answer에 저장된 내용을 처음부터 끝까지 따져보는게 가능하다. 처음 문제를 풀 때 시간을 확인 안했는데 앞으로 까먹는 일이 없도록 해야된다.
- 처음 시간을 줄일려고 보와 기둥을 저장하는 배열을 따로 저장했는데 그럴 필요 없없다. answer에 다 넣어서 확인한다. 
- 50행 
  - tmp vector를 만들어 넣은 후 answer에 넣으면 2차원 vector를 구현할 수 있다. 카카오에서 vector를 기본 입력값으로 주기 때문에 앞으로 많이 활용할 것 같다.
- 55행
  - 건설할 때 조건을 만족하면 answer에 넣고 조건을 만족하지 않으면 answer에서 빼준다. 
- 60행
  - 삭제할 내용을 일일이 찾아 인덱스를 저장한 후 조건에 맞으면 answer에서 지워준다. 조건에 맞지 않으면 다시 넣어야 하기 때문에 erase에 삭제할 내용을 백업한 후 다시 넣어준다.
  - 67행에서 erase 함수를 넣는 방법을 자주 쓰게 될 것 같다. 잊지않고 기억할 것
- 7행
  - 앞에서 말했듯이 조건을 하나하나 확인하여 따져본다.
- 14행, 15행, 21행
  - 이번 문제에서 처리가 곤란했다. 왼쪽 보와 오른쪽 보를 따로 확인했어야 했는데 같이 확인하여 당연히 값이 달라 false가 뜨게 되었다. 조건을 확실하게 따져보고 틀린 부분이 없나 검토해봐야한다.

### 13번 치킨 배달 333p
https://www.acmicpc.net/problem/15686

https://github.com/HongYouBin/ecote/blob/main/13.cpp

https://github.com/HongYouBin/ecote/blob/main/13-1.cpp

- 크게 2가지 방법으로 문제를 해결하였다. 두가지 방법 모두 brute force 방법으로 해결 가능하다.
- 1
  - 조합을 이용한다. 13_C_M 이기 때문에 경우의 수가 작게 나타난다.
  - C++에서 조합을 하는 방법을 헤맸다. 답을 보고 검색을 한 후에 해결 가능했다. next_permutaion이라는 stl을 사용했다. 앞으로 많이 나올 수 있으니 외워야 된다(https://blog.uniony.me/cpp/next_permutation/). 40행에서 46행까지 구현되었다. 구현할 때 어려웠던 부분은 앞 부분이 모두 0이고 뒷부분이 모두 1이어야 순열처럼 움직인다. 따라서 36행 주석처럼 구현하면 안되고 37행 처럼 앞은 0 뒤는 1로 구현해줘야 한다. 또한 vector에서 end를 작성할 때 헷갈린 부분이 있었는데 end는 vector 마지막 부분 다음의 iterator를 반환한다.
  - 11항
    - check함수를 이용해 하나하나 계산한다. 
- 2
  - dfs방법으로 문제를 해결한다.
    - 아이디어를 떠올리는 것은 쉬웠으나 매번 dfs 함수에 접근할 때마다 값을 계산하려 했고 종결 조건을 설정하는 과정에서 애를 먹었다. 답을 참고하니 visited 배열을 만들어서 방문할 때마다 true 값을 넣어 true 값이 나올 때만 계산하는 방법을 이용했다. 
